(in-package :rephrase)

(defclass symbols (rephrase)
  ((state :accessor state)
   (chars :accessor chars)
   (line :accessor line)
   (start-position :accessor start-position)))

(defmethod reset ((self symbols))
  (setf (state self) :idle)
  (setf (chars self) nil)
  (setf (line self) 0)
  (setf (start-position self) 0))

(defmethod filter ((self symbols) token-list)
  (flet ((symbol-start? (tok)
	   (and (eq :character (token-kind tok))
		(or (and (char<= #\A (token-text tok)) (char>= #\Z (token-text tok)))
		    (and (char<= #\a (token-text tok)) (char>= #\z (token-text tok))))))
	 (symbol-follow? (tok)
	   (and (eq :character (token-kind tok))
		(or (and (char<= #\A (token-text tok)) (char>= #\Z (token-text tok)))
		    (and (char<= #\a (token-text tok)) (char>= #\z (token-text tok)))
		    (and (char<= #\0 (token-text tok)) (char>= #\9 (token-text tok)))
		    (char= #\- (token-text tok)))))
	 (make-symbol-token ()
	   (let ((chars (reverse (chars self))))
	     (let ((str (with-output-to-string (s)
			  (@:loop
			    (@:exit-when (null chars))
			    (let ((ch (pop chars)))
			      (write-char ch s))))))
	       (make-token :kind :symbol
			   :text str
			   :line (line self)
			   :position (start-position self))))))
    (let ((output nil))
      (@:loop
	(@:exit-when (null token-list))
	(let ((tok (pop token-list)))
	  (ecase (state self)
	    (:idle
	     (cond ((eq :EOF (token-kind tok))
		    (push tok output)
		    (assert (null token-list)))
		   ((symbol-start? tok)
		    (setf (line self) (token-line tok))
		    (setf (start-position self) (token-position tok))
		    (push (token-text tok) (chars self))
		    (setf (state self) :collecting))
		   (t (push tok output))))
	    (:collecting
	     (cond ((eq :EOF (token-kind tok))
		    (push (make-symbol-token) output)
		    (push tok output)
		    (assert (null token-list)))
		   ((symbol-follow? tok)
		    (push (token-text tok) (chars self)))
		   (t
		    (push (make-symbol-token) output)
		    (push tok output)
		    (reset self)
		    (setf (state self) :idle))))
	    )))
      (reverse output))))

